Der umfassende Leitfaden zur Erstellung von n8n Community Nodes: Von der Idee bis zur VeröffentlichungEinleitungIn der Welt der Workflow-Automatisierung hat sich n8n als eine leistungsstarke, flexible und erweiterbare Open-Source-Plattform etabliert. Ihre Architektur, die auf einem modularen System von "Nodes" basiert, ermöglicht es technischen Teams, komplexe Prozesse durch die visuelle Verknüpfung von Diensten und Logikbausteinen zu automatisieren.1 Jede Node stellt dabei eine spezifische Funktion, eine Integration mit einem externen Dienst oder einen logischen Operator dar.Während n8n bereits Hunderte von integrierten Nodes für gängige Anwendungen und Dienste bietet, liegt die wahre Stärke der Plattform in ihrer unbegrenzten Erweiterbarkeit. Die Möglichkeit, eigene "Community Nodes" zu entwickeln, ist entscheidend für Unternehmen und Entwickler, die über die Standardintegrationen hinausgehen müssen. Ob es darum geht, eine proprietäre interne API anzubinden, eine hochspezialisierte Geschäftslogik zu implementieren oder eine Lücke im bestehenden Katalog von Integrationen zu schließen – die Erstellung einer benutzerdefinierten Node ist oft der Schlüssel zur Realisierung des vollen Automatisierungspotenzials.4Dieser Leitfaden dient als umfassendes technisches Kompendium für den gesamten Lebenszyklus der Node-Entwicklung. Er richtet sich an Entwickler und technisch versierte Anwender, die ihre n8n-Instanzen um maßgeschneiderte Funktionalitäten erweitern möchten. Basierend auf der offiziellen n8n-Dokumentation, den von n8n bereitgestellten Entwickler-Tools und den wertvollen Praxiserfahrungen aus der Community, führt dieser Bericht strukturiert durch alle notwendigen Phasen: von den konzeptionellen Grundlagen und der Einrichtung der Entwicklungsumgebung über die detaillierte Entwicklung programmatischer und deklarativer Nodes bis hin zum Testen, der Fehlerbehebung und schließlich der Veröffentlichung und Verifizierung der fertigen Node.6Abschnitt 1: Grundlegende Konzepte und VorbereitungenBevor die eigentliche Entwicklung beginnen kann, ist es unerlässlich, ein solides Fundament zu legen. Dieser Abschnitt stellt sicher, dass alle notwendigen technischen, konzeptionellen und werkzeugseitigen Voraussetzungen erfüllt sind, um einen reibungslosen und erfolgreichen Entwicklungsprozess zu gewährleisten.1.1. Technische und konzeptionelle VoraussetzungenDie Erstellung einer n8n-Node ist eine anspruchsvolle Entwicklungsaufgabe, die ein spezifisches Set an Fähigkeiten und Kenntnissen erfordert. Eine gründliche Vorbereitung in diesen Bereichen ist entscheidend, um häufige Fallstricke zu vermeiden und qualitativ hochwertigen Code zu produzieren.Programmierkenntnisse: Solide bis fortgeschrittene Kenntnisse in JavaScript und insbesondere in TypeScript sind nicht verhandelbar. Da n8n-Nodes in TypeScript geschrieben werden, ist ein tiefes Verständnis von Typen, Klassen, Interfaces und asynchroner Programmierung (async/await) unerlässlich.6Entwicklungsumgebung und Werkzeuge: Entwickler müssen in der Lage sein, ihre eigene Entwicklungsumgebung selbstständig zu verwalten. Dies schließt die sichere Verwendung von Git für die Versionskontrolle und die Interaktion mit GitHub-Repositories ein. Ebenso ist ein fundiertes Wissen über npm (Node Package Manager) oder pnpm erforderlich, einschließlich der Erstellung von package.json-Dateien, der Verwaltung von Abhängigkeiten und der Veröffentlichung von Paketen in der npm-Registry.6n8n-spezifisches Wissen: Eine rein theoretische Kenntnis der Programmierung reicht nicht aus. Eine grundlegende Vertrautheit mit der Funktionsweise von n8n selbst ist zwingend erforderlich. Dazu gehört vor allem ein gutes Verständnis der internen Datenstruktur – wie Datenobjekte als Array von Items zwischen den Nodes fließen – und des Konzepts des "Item Linking", das es ermöglicht, auf Daten aus vorhergehenden Nodes zuzugreifen.61.2. Einrichten der EntwicklungsumgebungEine korrekt konfigurierte Entwicklungsumgebung ist die Basis für effizientes Arbeiten. Die folgenden Werkzeuge müssen installiert und konfiguriert werden:Node.js und Paketmanager: Die Installation von Node.js ist die primäre Voraussetzung. Die n8n-Dokumentation und die Starter-Projekte geben spezifische Mindestversionen vor, die unbedingt eingehalten werden müssen, beispielsweise Node.js Version 20.x oder höher.7 Es wird dringend empfohlen, einen Versionsmanager wie nvm (Node Version Manager) zu verwenden, um flexibel zwischen verschiedenen Node.js-Versionen wechseln zu können.Git: Das Versionskontrollsystem Git ist für das Klonen des Starter-Projekts und die Verwaltung des eigenen Codes unerlässlich.Globale n8n-Installation: Eine globale Installation von n8n über den Befehl npm install -g n8n ist eine empfohlene Praxis. Sie ermöglicht es, die selbst entwickelte Node in einer lokalen n8n-Instanz schnell und unkompliziert zu testen, bevor man sich mit komplexeren Setups wie Docker befasst.5Code-Editor: Ein moderner Code-Editor, der TypeScript und die damit verbundenen Werkzeuge (wie Linter und Prettier) gut unterstützt, ist für eine produktive Entwicklung unerlässlich. Visual Studio Code (VS Code) ist hierfür eine weit verbreitete und sehr empfehlenswerte Wahl.1.3. Initialisierung des Projekts mit n8n-nodes-starterAnstatt ein Projekt von Grund auf neu zu erstellen, stellt n8n ein offizielles Starter-Repository zur Verfügung. Dieses Vorgehen wird dringend empfohlen, da das n8n-nodes-starter-Repository eine korrekte Projektstruktur, alle notwendigen Build-Skripte und Abhängigkeiten sowie einen vorkonfigurierten Linter zur Sicherstellung der Codequalität bereitstellt.7Der Prozess der Initialisierung ist wie folgt:Repository von Vorlage erstellen: Navigieren Sie zur GitHub-Seite des Starter-Projekts und verwenden Sie die Funktion "Use this template" -> "Create a new repository". Dadurch wird eine Kopie des Starter-Projekts in Ihrem eigenen GitHub-Account erstellt, ohne die gesamte Historie zu forken.4Lokales Klonen: Klonen Sie Ihr neu erstelltes Repository auf Ihre lokale Entwicklungsmaschine mit dem Befehl: git clone https://github.com/<Ihr-GitHub-Benutzername>/<Ihr-Repo-Name>.git.Abhängigkeiten installieren: Wechseln Sie in das Projektverzeichnis und installieren Sie die Abhängigkeiten. An dieser Stelle ist eine wichtige Klarstellung notwendig: Während ältere Anleitungen und viele Community-Beiträge den Befehl npm install verwenden 5, wurde das offizielle n8n-nodes-starter-Repository auf pnpm als Paketmanager umgestellt.11 Dies geschah, um die Entwicklung von Community-Nodes an die Entwicklung des n8n-Kernprodukts anzugleichen. Die Verwendung von pnpm ist daher die aktuell korrekte und empfohlene Methode, um subtile Abhängigkeitskonflikte zu vermeiden. Der korrekte Befehl lautet also: pnpm install.Die Nichtbeachtung dieses Wechsels von npm zu pnpm ist eine häufige Fehlerquelle für Entwickler, die mit veralteten Anleitungen arbeiten, und kann zu schwer diagnostizierbaren Problemen beim lokalen Testen führen.Die folgende Tabelle fasst die wesentlichen Voraussetzungen zusammen und dient als Checkliste für die Vorbereitung.Tabelle 1: Checkliste der VoraussetzungenKategorieElementVersion/AnforderungQuelleSoftwareNode.js>= 20.x (Prüfen Sie die aktuelle Anforderung im Starter-Repo)7pnpmNeueste Version11GitNeueste Version7n8n (global)Neueste Version (npm install -g n8n)7KenntnisseTypeScriptFortgeschritten6Git & GitHubSicherer Umgang6npm/pnpmPaketverwaltung, Veröffentlichung6n8n-KonzepteDatenstruktur, Item Linking6Abschnitt 2: Die Anatomie einer n8n-NodeDas Verständnis der internen Struktur eines Node-Projekts ist fundamental, um effektiv entwickeln, Fehler beheben und die von n8n etablierten Konventionen einhalten zu können. Jede Datei und jedes Verzeichnis hat einen spezifischen Zweck, der zum reibungslosen Zusammenspiel von Node, n8n-Core und Benutzeroberfläche beiträgt.2.1. Empfohlene DateistrukturDas n8n-nodes-starter-Projekt gibt eine klare und bewährte Dateistruktur vor, die als Grundlage für jede benutzerdefinierte Node dienen sollte.Projekt-Root: Auf der obersten Ebene des Projekts befinden sich die zentralen Konfigurationsdateien, die das Verhalten des Compilers, des Linters und des Paketmanagers steuern. Dazu gehören package.json, tsconfig.json (für TypeScript-Compiler-Optionen) und .eslintrc.js (für Linting-Regeln).7/nodes-Verzeichnis: Dies ist das Herzstück des Projekts. Es enthält den gesamten Quellcode für die eigentlichen Nodes. Es ist eine Best Practice, für jede einzelne Node, die Sie entwickeln, ein eigenes Unterverzeichnis anzulegen (z.B. /nodes/MyCustomNode/). Dies fördert die Modularität und Übersichtlichkeit, insbesondere wenn ein Paket mehrere Nodes enthalten soll.10/credentials-Verzeichnis: Dieses Verzeichnis ist für die Definitionen der Anmeldeinformationen reserviert. Wenn Ihre Node eine Authentifizierung gegenüber einem externen Dienst erfordert (z.B. über einen API-Schlüssel), wird die entsprechende Logik hier definiert. Auch hier sollte für jede Art von Anmeldeinformation eine eigene Datei angelegt werden (z.B. /credentials/MyCustomApi.credentials.ts).4Struktur für komplexe Nodes: Bei sehr komplexen Nodes, die viele verschiedene Operationen oder Ressourcen verwalten, empfiehlt es sich, die Struktur innerhalb des Node-Verzeichnisses weiter zu unterteilen. Offizielle n8n-Nodes wie die für Airtable oder Microsoft Outlook verwenden hierfür Unterordner wie actions, methods und transport, um die Logik thematisch zu gruppieren. Dies ist ein fortgeschrittenes Muster, das die Wartbarkeit erheblich verbessert.13Organisatorische Einschränkungen: Es ist wichtig zu wissen, dass ältere n8n-Entwicklungswerkzeuge wie n8n-node-dev das automatische Bauen von Nodes in verschachtelten Unterverzeichnissen nicht immer gut unterstützten. Der moderne Ansatz, der auf dem n8n-nodes-starter-Paket basiert, löst dies durch klare Build-Skripte und die explizite Deklaration der Dateipfade in der package.json, was die Organisation erheblich vereinfacht.142.2. Die zentralen Dateien und ihre RollenInnerhalb der Verzeichnisstruktur sind drei Dateitypen von zentraler Bedeutung:<name>.node.ts: Die Haupt-TypeScript-Datei der Node. Sie enthält die Klasse, die das INodeType-Interface von n8n implementiert. In dieser Datei werden die visuellen Eigenschaften der Node (die Felder in der Benutzeroberfläche), die verfügbaren Operationen (z.B. "Get User", "Create Document") und – im Falle einer programmatischen Node – die eigentliche Ausführungslogik in der execute-Methode definiert.4<name>.node.json (Codex-Datei): Diese JSON-Datei ist optional, wird aber dringend empfohlen. Sie enthält statische Metadaten über die Node, die von der n8n-Benutzeroberfläche gelesen werden, um die Node im Menü korrekt anzuzeigen. Dazu gehören der Anzeigename (displayName), der interne Name (name), das Icon (icon), die Gruppenzugehörigkeit (group) und die Version (version). Die Verwendung dieser Datei entlastet die .node.ts-Datei von statischen Informationen.5<name>.credentials.ts: Diese Datei ist nur erforderlich, wenn Ihre Node eine Authentifizierung benötigt. Sie definiert eine Klasse, die das ICredentialType-Interface implementiert. Hier werden die Felder spezifiziert, die der Benutzer im Anmeldeinformations-Dialog ausfüllen muss (z.B. "API Key", "Client ID"), und vor allem, wie diese Informationen für die Authentifizierung bei API-Anfragen verwendet werden sollen.42.3. Essenzielle Konfiguration der package.jsonDie package.json-Datei ist mehr als nur eine Liste von Abhängigkeiten; sie ist die Visitenkarte Ihrer Node und enthält entscheidende Direktiven für n8n. Eine fehlerhafte Konfiguration hier ist eine der häufigsten Ursachen dafür, dass eine Node nicht in der n8n-UI erscheint.5Namenskonvention: Der Paketname (name) muss zwingend mit dem Präfix n8n-nodes- beginnen. Alternativ kann ein gescopter Name wie @mein-scope/n8n-nodes-meine-node verwendet werden. Diese Konvention ermöglicht es n8n, Community-Node-Pakete zu identifizieren.17Keyword: Das keywords-Array muss den String n8n-community-node-package enthalten. Dies ist ein weiteres Kriterium, das n8n verwendet, um relevante Pakete zu finden.17Das n8n-Attribut: Dies ist das wichtigste und funktional kritischste Feld. Es handelt sich um ein Objekt, das dem n8n-Core-Prozess explizit mitteilt, welche kompilierten JavaScript-Dateien als Nodes und welche als Credentials geladen werden sollen. Es ist keine reine Metainformation, sondern eine funktionale Anweisung. Wenn n8n eine Community-Node lädt, liest es gezielt dieses Attribut, anstatt das gesamte Paket zu durchsuchen. Dies ist ein performanter und sicherer Mechanismus. Ein typischer Eintrag sieht so aus:JSON"n8n": {
  "credentials": [
    "dist/credentials/MyCustomApi.credentials.js"
  ],
  "nodes": [
    "dist/nodes/MyCustomNode/MyCustomNode.node.js"
  ]
}
Die Pfade müssen auf die kompilierten Dateien im dist-Verzeichnis verweisen, nicht auf die TypeScript-Quelldateien.17Die folgende Tabelle fasst die obligatorischen Felder der package.json für eine funktionierende Community-Node zusammen.Tabelle 2: package.json: Erforderliche Felder für Community NodesAttributBeispielwertZweckQuellename"n8n-nodes-mein-service"Eindeutiger Paketname. Muss mit n8n-nodes- beginnen, um von n8n erkannt zu werden.17keywords["n8n-community-node-package"]Macht das Paket für die n8n-Community-Node-Suche auffindbar.17n8n.nodes["dist/nodes/MyNode.node.js"]Funktionale Direktive: Teilt n8n den genauen Pfad zur kompilierten Node-Datei mit.17n8n.credentials["dist/credentials/MyApi.credentials.js"]Funktionale Direktive: Teilt n8n den genauen Pfad zur kompilierten Credential-Datei mit.17Abschnitt 3: Wahl des Entwicklungsstils: Deklarativ vs. ProgrammatischEine der ersten und wichtigsten architektonischen Entscheidungen bei der Erstellung einer neuen Node ist die Wahl zwischen dem deklarativen und dem programmatischen Entwicklungsstil. Diese Entscheidung hat weitreichende Konsequenzen für den Entwicklungsaufwand, die Flexibilität und die Wartbarkeit der Node. n8n bietet beide Ansätze, um eine breite Palette von Anwendungsfällen optimal abzudecken.3.1. Der deklarative AnsatzDer deklarative Stil ist der von n8n empfohlene Ansatz für die meisten Anwendungsfälle, insbesondere für die Integration von Standard-REST-APIs. Anstatt die Logik prozedural in Code zu schreiben, beschreibt man das gewünschte Verhalten der Node mithilfe einer JSON-basierten Syntax.5Vorteile:Geringerer Code-Umfang: Da viele wiederkehrende Aufgaben wie die Erstellung von HTTP-Anfragen, Fehlerbehandlung und Paginierung vom n8n-Core übernommen werden, ist deutlich weniger benutzerdefinierter Code erforderlich.5Geringere Fehleranfälligkeit: Weniger Code bedeutet weniger potenzielle Fehlerquellen. Die strukturierte JSON-Syntax minimiert das Risiko von logischen Fehlern.Zukunftssicherheit: Da die Implementierungsdetails von n8n verwaltet werden, profitieren deklarative Nodes automatisch von Verbesserungen und neuen Funktionen im n8n-Core, ohne dass der Node-Code selbst angepasst werden muss.19Kernkonzept: Das Herzstück einer deklarativen Node ist das routing-Objekt, das innerhalb jeder operations-Definition platziert wird. Dieses Objekt definiert, wie eine API-Anfrage für diese spezifische Operation aufgebaut werden soll, einschließlich der HTTP-Methode, der URL, der Header und des Bodys. Eine explizite execute-Methode ist nicht erforderlich.193.2. Der programmatische AnsatzDer programmatische Ansatz bietet maximale Flexibilität und Kontrolle, erfordert aber auch einen deutlich höheren Entwicklungsaufwand. Hier wird die gesamte Logik der Node in TypeScript innerhalb einer execute-Methode implementiert.10Zwingende Anwendungsfälle: In bestimmten Szenarien ist die Verwendung des programmatischen Stils nicht nur eine Option, sondern eine Notwendigkeit:Trigger Nodes: Nodes, die einen Workflow starten (z.B. durch Webhooks oder Polling), müssen immer programmatisch implementiert werden, da sie eine komplexe Logik zur Ereignisbehandlung erfordern.3Nicht-REST-basierte Integrationen: Wenn die anzubindende Schnittstelle kein Standard-REST-API ist (z.B. eine GraphQL-API, eine SOAP-Schnittstelle oder eine Datenbankverbindung über ein spezifisches Protokoll), muss die Logik programmatisch abgebildet werden.19Verwendung externer Bibliotheken: Sobald eine Node auf eine externe npm-Bibliothek angewiesen ist, um eine bestimmte Aufgabe zu erfüllen (z.B. eine komplexe kryptografische Operation), ist der programmatische Stil erforderlich.Komplexe Daten-Transformation: Wenn die von einer API empfangenen Daten vor der Weitergabe im Workflow stark transformiert, gefiltert oder angereichert werden müssen oder wenn die an die API zu sendenden Daten aus mehreren Quellen dynamisch zusammengesetzt werden müssen, bietet nur die execute-Methode die dafür nötige Flexibilität.19Vollständiges Versioning: Für Nodes, die komplexe Versionierungsstrategien mit abweichender Logik zwischen den Versionen benötigen, ist der programmatische Ansatz unumgänglich.19Die Wahl des Stils ist keine Entscheidung, die für ein gesamtes Node-Paket getroffen werden muss. Vielmehr handelt es sich um eine Entscheidung pro Node. Ein hybrider Ansatz ist nicht nur möglich, sondern oft die beste Lösung. Ein hervorragendes Beispiel hierfür ist die offizielle Brevo-Node von n8n: Die Haupt-Node, die Aktionen wie das Senden von E-Mails durchführt, ist effizient im deklarativen Stil implementiert. Die zugehörige Trigger-Node, die auf Ereignisse wie "E-Mail geöffnet" reagiert, ist notwendigerweise programmatisch.20 Dieser "Best of both worlds"-Ansatz ermöglicht es Entwicklern, für jede Aufgabe das am besten geeignete Werkzeug zu wählen, was zu effizienterem und besser wartbarem Code führt.Die folgende Tabelle stellt die beiden Ansätze detailliert gegenüber, um eine fundierte Entscheidungsgrundlage zu schaffen.Tabelle 3: Deklarativ vs. Programmatisch – Ein detaillierter VergleichKriteriumDeklarativer StilProgrammatischer StilPrimärer AnwendungsfallStandard-REST-API-IntegrationenTrigger, Nicht-REST-APIs, komplexe LogikCode-BasisJSON-basierte KonfigurationTypeScript-CodeEntwicklungsaufwandGeringHochFlexibilitätBegrenzt auf die von n8n bereitgestellten OptionenMaximal, volle Kontrolle über den AusführungsflussDaten-TransformationSehr eingeschränktVollständig und flexibel möglichTrigger-UnterstützungNeinJa, zwingend erforderlichFehlerbehandlungGrößtenteils von n8n übernommenMuss manuell implementiert werdenPaginierungOft durch eine einfache Konfiguration unterstütztMuss manuell implementiert werdenZukunftssicherheitHoch, profitiert von Core-UpdatesGeringer, erfordert manuelle AnpassungenAbschnitt 4: Detaillierte Entwicklung einer programmatischen NodeDer programmatische Ansatz ist die Königsdisziplin der Node-Entwicklung. Er gewährt vollständige Kontrolle und Flexibilität, erfordert aber auch ein tiefes Verständnis der n8n-internen Mechanismen. Dieser Abschnitt führt Schritt für Schritt durch die Erstellung einer solchen Node.4.1. Definition der Node-Struktur und -EigenschaftenDie Basis jeder Node ist eine TypeScript-Klasse, die das INodeType-Interface implementiert. Diese Klasse definiert das Erscheinungsbild und die grundlegenden Metadaten der Node.12Das description-Objekt: Dieses Objekt ist das zentrale Konfigurationselement und beschreibt, wie die Node in der n8n-UI dargestellt wird und wie sie sich verhält. Zu den wichtigsten Eigenschaften gehören:displayName: Der für den Benutzer sichtbare Name der Node (z.B. "Mein CRM").name: Der interne, eindeutige Name in "camelCase" (z.B. "myCrm").group: Die Kategorie, unter der die Node im "Add Node"-Dialog erscheint (z.B. ['transform']).version: Die Versionsnummer der Node-Definition (z.B. 1).description: Eine kurze Beschreibung der Node-Funktionalität.icon: Ein Verweis auf eine Icon-Datei (z.B. file:myCrm.svg).10inputs: Definiert die Anzahl und Art der Eingangsverbindungen (meist ['main']).outputs: Definiert die Anzahl und Art der Ausgangsverbindungen (meist ['main']).defaults: Standardwerte für die Node, z.B. der Name, der beim Hinzufügen zum Workflow angezeigt wird.4Das properties-Array: Dieses Array definiert die eigentliche Benutzeroberfläche der Node, also die Felder, die der Benutzer konfigurieren kann. Jedes Objekt im Array repräsentiert ein UI-Element (z.B. ein Textfeld, eine Dropdown-Liste, ein Schalter). Die wichtigsten Attribute für jedes Property sind:displayName: Die Beschriftung des Feldes in der UI.name: Der interne Name des Parameters, über den der Wert später im Code abgerufen wird.type: Der Typ des Feldes, z.B. 'string', 'number', 'boolean', 'options', 'collection'.default: Ein Standardwert für das Feld.Weitere Optionen wie required, placeholder, description steuern das Verhalten und Aussehen des Feldes weiter.44.2. Implementierung der execute-MethodeDie execute-Methode ist das logische Herzstück jeder programmatischen Node. Sie wird bei jeder Ausführung des Workflows aufgerufen und enthält den Code, der die eigentliche Arbeit verrichtet.10Rolle und Signatur: Es handelt sich um eine async-Methode, die ein Promise<INodeExecutionData> zurückgeben muss. Dies spiegelt die asynchrone Natur von API-Aufrufen und die Datenstruktur von n8n wider.Zugriff auf Eingabedaten:Mit const items = this.getInputData(); wird ein Array aller ankommenden Daten-Items von der vorhergehenden Node abgerufen. Es ist eine Best Practice, durch dieses items-Array zu iterieren, um jeden Datensatz einzeln zu verarbeiten und so das "Looping"-Verhalten von n8n korrekt zu unterstützen.4Mit this.getNodeParameter('parameterName', i) wird der Wert eines Parameters aus der UI für das aktuell in der Schleife verarbeitete Item (mit dem Index i) ausgelesen. Dies ist entscheidend, um dynamische Werte zu verarbeiten, die über Expressions aus vorhergehenden Nodes stammen.10Ausgabe der Ergebnisse: Nach der Verarbeitung der Daten müssen die Ergebnisse in dem von n8n erwarteten Format zurückgegeben werden. Die Hilfsfunktion this.helpers.returnJsonArray(returnData) ist hierfür das Mittel der Wahl. Sie nimmt ein Array von JavaScript-Objekten entgegen und formatiert es korrekt in die INodeExecutionData-Struktur, die n8n für die Weitergabe an die nächste Node benötigt.104.3. Sicherer Umgang mit Anmeldeinformationen (credentials)Die Verwaltung von sensiblen Daten wie API-Schlüsseln ist ein kritischer Aspekt. n8n bietet hierfür einen sicheren und eleganten Mechanismus, der die Logik der Node von der Mechanik der Authentifizierung trennt.Definition in <name>.credentials.ts: Die Definition der Anmeldeinformationen erfolgt in einer separaten Datei. Die Klasse implementiert ICredentialType und definiert:name: Ein interner Name für den Credential-Typ (z.B. myCrmApi).displayName: Der in der UI angezeigte Name.properties: Ein Array von INodeProperties, das die Felder im Credential-Dialog definiert (z.B. ein Feld für den API-Schlüssel).4Das authenticate-Objekt: Dies ist der entscheidende Teil. Anstatt die Authentifizierungs-Header manuell im Code zusammenzubauen, deklariert man hier, wie die Authentifizierung erfolgen soll. n8n kümmert sich dann um die korrekte Anwendung. Man kann festlegen, dass die Credentials im header, in der qs (Query String), im body oder als auth (für Basic Auth) gesendet werden.15 Beispiel für einen Bearer-Token im Header:TypeScriptauthenticate: IAuthenticateGeneric = {
    type: 'generic',
    properties: {
        header: {
            'Authorization': '=Bearer {{$credentials.apiKey}}'
        },
    },
};
Verknüpfung und Zugriff:In der .node.ts-Datei wird im description-Objekt ein credentials-Array deklariert, das auf den name der Credential-Klasse verweist (z.B. credentials: [{ name: 'myCrmApi', required: true }]).4Innerhalb der execute-Methode werden die Anmeldeinformationen sicher mit const credentials = await this.getCredentials('myCrmApi'); abgerufen.4Für den eigentlichen API-Aufruf wird die Hilfsfunktion this.helpers.requestWithAuthentication.call(this, 'myCrmApi', options) verwendet. n8n liest die authenticate-Definition aus der Credential-Datei und fügt die Authentifizierungsinformationen automatisch und sicher zur Anfrage hinzu. Der Node-Entwickler muss sich nicht um die Details der Header-Erstellung kümmern.10Dieses Muster, bei dem die Authentifizierungsmechanik deklarativ in der Credential-Datei definiert und dann programmatisch über eine Hilfsfunktion aufgerufen wird, ist ein Kernprinzip der n8n-Node-Entwicklung. Es sorgt für sauberen, sicheren und wartbaren Code, indem es die Belange klar voneinander trennt.Abschnitt 5: Detaillierte Entwicklung einer deklarativen NodeDer deklarative Ansatz stellt eine hochgradig spezialisierte Abstraktion dar, die speziell für die Interaktion mit REST-APIs entwickelt wurde. Man kann ihn als eine Art domänenspezifische Sprache (DSL) in Form von JSON betrachten, die es ermöglicht, API-Interaktionen zu beschreiben, anstatt sie zu programmieren. Dies macht die Entwicklung erheblich schneller und weniger fehleranfällig, solange man sich innerhalb der von der DSL vorgegebenen Grenzen bewegt.5.1. JSON-basierte DefinitionDie Grundstruktur einer deklarativen Node ähnelt zunächst der einer programmatischen Node. Man erstellt eine TypeScript-Klasse, die INodeType implementiert und ein description-Objekt enthält, das die Metadaten und die UI-Properties definiert. Der entscheidende Unterschied ist das Fehlen einer execute-Methode. Stattdessen wird die gesamte Logik innerhalb der operations-Eigenschaft des description-Objekts definiert.20Das operations-Array: Dieses Array enthält ein Objekt für jede Operation, die die Node ausführen kann (z.B. "Get Picture of the Day"). Jedes dieser Objekte enthält wiederum UI-Properties, die nur für diese spezifische Operation angezeigt werden, sowie das entscheidende routing-Objekt.5.2. Konfiguration von API-Anfragen über routingDas routing-Objekt ist das Herzstück der deklarativen Logik. Es teilt dem n8n-Core genau mit, wie die HTTP-Anfrage für die ausgewählte Operation aufgebaut und gesendet werden soll.19Das request-Objekt: Hier wird die eigentliche HTTP-Anfrage definiert. Zu den wichtigsten Eigenschaften gehören:method: Die HTTP-Methode, z.B. 'GET', 'POST'.url: Die Ziel-URL des API-Endpunkts.qs (Query String): Ein Objekt, dessen Schlüssel-Wert-Paare als Query-Parameter an die URL angehängt werden.body: Ein Objekt, das als JSON-Payload im Request-Body gesendet wird.headers: Ein Objekt zur Definition von benutzerdefinierten HTTP-Headern.Verwendung dynamischer Werte: Um auf die vom Benutzer in der UI eingegebenen Werte zuzugreifen, verwendet man eine spezielle Platzhaltersyntax. Beispielsweise würde ={{$parameter.date}} den Wert des Parameters mit dem internen Namen date in die Anfrage einfügen. Um auf Anmeldeinformationen zuzugreifen, verwendet man ={{$credentials.apiKey}}.Paginierung und weitere Optionen: Der deklarative Stil bietet oft auch eingebaute Mechanismen für komplexere Aufgaben wie die Paginierung, die durch zusätzliche Eigenschaften im routing-Objekt konfiguriert werden können.5Ein kommentiertes Beispiel für eine Operation in einer deklarativen Node könnte wie folgt aussehen (basierend auf den Tutorials 20):TypeScript// Innerhalb des description-Objekts
operations:,
            },
        },
    },
],
Das Verständnis des deklarativen Stils als eine DSL ist entscheidend. Er ist extrem leistungsfähig und effizient für seinen vorgesehenen Zweck – die Anbindung von REST-APIs. Sobald jedoch eine Logik erforderlich wird, die über die Beschreibung einer einfachen Anfrage-Antwort-Interaktion hinausgeht (z.B. bedingte Logik innerhalb einer Ausführung, komplexe Datenmanipulationen), stößt die DSL an ihre Grenzen. In diesem Fall muss auf die universelle "Sprache" des programmatischen Stils zurückgegriffen werden.Abschnitt 6: Testen, Debuggen und FehlerbehebungDie Entwicklung einer Node ist nur die halbe Miete. Ein rigoroser Test- und Debugging-Prozess ist entscheidend, um eine stabile und zuverlässige Node zu gewährleisten. Dieser Abschnitt behandelt bewährte Strategien für das lokale Testen und bietet einen detaillierten Leitfaden zur Lösung der häufigsten Probleme, die während der Entwicklung auftreten, basierend auf den kollektiven Erfahrungen der n8n-Community.6.1. Strategien für das lokale TestenEffizientes lokales Testen ist der Schlüssel zu einem schnellen Entwicklungszyklus. Anstatt die Node nach jeder Änderung zu veröffentlichen, gibt es mehrere Methoden, um sie direkt auf der lokalen Maschine auszuführen.Verknüpfen des Pakets mit pnpm link: Dies ist die grundlegendste Methode. Der Befehl pnpm link erstellt einen symbolischen Link von Ihrem Node-Projektverzeichnis zum globalen Node.js-Modulverzeichnis. Ein anschließender pnpm link <paketname> im n8n-Benutzerverzeichnis (~/.n8n/) oder im custom-Verzeichnis (~/.n8n/custom/) sorgt dafür, dass Ihre lokale n8n-Instanz Ihre Node beim Start lädt. Dies ermöglicht es, Änderungen am Code vorzunehmen und sie nach einem Neustart von n8n sofort zu sehen.5Isoliertes Testen mit Docker: Ein sauberer und reproduzierbarer Ansatz ist die Verwendung von Docker. Hierbei wird eine Dockerfile erstellt, die vom offiziellen n8n-Image erbt und das lokale, kompilierte Node-Verzeichnis in den Container unter /home/node/.n8n/custom/ kopiert. Eine docker-compose.yml-Datei kann dann verwendet werden, um die n8n-Instanz zusammen mit eventuellen Abhängigkeiten wie einer Datenbank zu starten. Dies stellt eine isolierte Testumgebung sicher, die der Produktionsumgebung sehr nahe kommt.12Der effiziente Entwicklungs-Workflow: Community-Diskussionen haben einen besonders effizienten lokalen Workflow hervorgebracht, der eine häufige Fehlerquelle umgeht. Viele Entwickler stolpern über die irreführenden Skriptnamen dev und start. Während npm run dev (oder pnpm run dev) den Frontend-Entwicklungsserver startet (oft auf Port 8080), lädt dieser nicht immer zuverlässig die benutzerdefinierten Nodes. Der bewährte Weg ist, stattdessen npm run start (oder pnpm run start) zu verwenden, das den vollständigen n8n-Backend-Prozess startet und die Nodes korrekt lädt (standardmäßig auf Port 5678). Der empfohlene Workflow sieht daher wie folgt aus:Öffnen Sie ein Terminal und führen Sie pnpm run watch aus. Dieser Prozess überwacht Ihre TypeScript-Dateien und kompiliert sie bei jeder Änderung automatisch nach JavaScript in das dist-Verzeichnis.Öffnen Sie ein zweites Terminal und führen Sie n8n start oder pnpm run start aus, um den n8n-Server zu starten.Wenn Sie nun Änderungen an der Logik innerhalb der execute-Methode vornehmen, werden diese nach dem Speichern und automatischen Kompilieren sofort bei der nächsten Ausführung des Workflows wirksam. Wenn Sie jedoch die Parameter der Node (also die UI-Eigenschaften im description-Objekt) ändern, müssen Sie den n8n start-Prozess manuell neu starten, da diese Definitionen nur beim Initialisieren des Servers geladen werden.166.2. Analyse und Lösung häufiger ProblemeDie folgende Tabelle dient als praktischer Leitfaden zur Fehlerbehebung. Sie fasst die häufigsten Probleme, ihre Ursachen und bewährte Lösungen zusammen, die aus der offiziellen Dokumentation und zahlreichen Community-Forum-Beiträgen destilliert wurden.Tabelle 4: Leitfaden zur FehlerbehebungSymptom / FehlermeldungMögliche UrsachenLösungsschritteRelevante QuellenNode erscheint nicht in der UI1. package.json ist falsch konfiguriert (fehlendes/falsches n8n-Attribut, falscher name oder keywords).
2. Der Build-Schritt (pnpm run build) wurde vergessen.
3. Der pnpm link-Befehl wurde nicht korrekt ausgeführt.
4. Der n8n-Server wurde nach der Änderung nicht neu gestartet.1. Überprüfen Sie die package.json akribisch anhand der Anforderungen in Abschnitt 2.3.
2. Führen Sie pnpm run build manuell aus.
3. Führen Sie den pnpm link-Prozess erneut durch.
4. Stoppen und starten Sie den n8n-Prozess.5Error: Credentials of type "..." aren't knownDer interne name in der Credential-Klasse (<name>.credentials.ts) stimmt nicht exakt mit dem Namen überein, der im credentials-Array der Node-Definition (<name>.node.ts) referenziert wird.Vergleichen Sie die beiden Zeichenketten auf Tippfehler, Groß-/Kleinschreibung und Leerzeichen. Sie müssen identisch sein.22Node kann nicht als Werkzeug für einen KI-Agenten verwendet werdenDieses Feature ist aus Sicherheitsgründen für Community-Nodes standardmäßig deaktiviert.1. Setzen Sie die Umgebungsvariable N8N_COMMUNITY_PACKAGES_ALLOW_TOOL_USAGE=true für Ihre n8n-Instanz.
2. Fügen Sie die Eigenschaft usableAsTool: true zur Node-Definition in der .node.ts-Datei hinzu.23Error: There was a problem loading init data: API-Server can not be reached.Dies tritt oft auf, wenn pnpm run dev verwendet wird. Der Frontend-Server kann das Backend nicht erreichen.Verwenden Sie stattdessen n8n start oder pnpm run start, um den vollständigen Server zu starten. Stellen Sie sicher, dass kein anderer Prozess den Port 5678 blockiert.16Änderungen an Node-Parametern (properties) werden nicht angezeigtDie Node-Definitionen werden nur beim Start des n8n-Servers geladen. Ein einfacher Refresh der UI reicht nicht aus.Stoppen Sie den n8n-Prozess (mit Ctrl + C) und starten Sie ihn mit n8n start neu.16Node-Icon wird nicht angezeigt1. Das Icon ist nicht im selben Ordner wie die Node-Datei.
2. Falsches Format (nur SVG oder PNG erlaubt).
3. Falscher Verweis in der icon-Eigenschaft.1. Platzieren Sie die Icon-Datei im Node-Verzeichnis.
2. Stellen Sie sicher, dass das Icon ein SVG oder ein 60x60px PNG ist.
3. Der Verweis muss das file:-Präfix und die Dateiendung enthalten, z.B. icon: 'file:myIcon.svg'.22Error: Cannot find module '<module>'Eine externe Bibliothek wurde im Code importiert, aber nicht korrekt für die n8n-Umgebung installiert.Wenn Sie n8n mit npm/pnpm betreiben, installieren Sie das Modul in derselben Umgebung. Wenn Sie Docker verwenden, müssen Sie ein benutzerdefiniertes Docker-Image erstellen, das das offizielle n8n-Image erweitert und das benötigte Modul installiert.24Abschnitt 7: Veröffentlichung und VerifizierungNachdem die Node entwickelt, gründlich getestet und debugged wurde, ist der letzte Schritt, sie der n8n-Community zur Verfügung zu stellen. Dieser Prozess gliedert sich in zwei Phasen: die Veröffentlichung als öffentliches npm-Paket und die optionale, aber empfohlene Einreichung zur Verifizierung durch das n8n-Team.7.1. Vorbereitung und Veröffentlichung auf npmJede Community-Node ist im Kern ein npm-Paket. Um Ihre Node für andere n8n-Benutzer installierbar zu machen, muss sie in der öffentlichen npm-Registry veröffentlicht werden.Qualitätssicherung: Führen Sie vor der Veröffentlichung einen letzten Check mit dem n8n-Linter durch. Der Befehl pnpm run lintfix kann viele Stil- und Formatierungsprobleme automatisch beheben und stellt sicher, dass Ihr Code den n8n-Standards entspricht.7Dokumentation: Eine aussagekräftige README.md-Datei ist unerlässlich. Sie ist die erste Anlaufstelle für Benutzer, die Ihre Node verwenden möchten. Erklären Sie, was die Node tut, welche Operationen sie unterstützt und wie die Anmeldeinformationen konfiguriert werden müssen. Das n8n-nodes-starter-Repository enthält eine README_TEMPLATE.md, die als hervorragende Vorlage dient.7Finalisierung der package.json: Überprüfen Sie alle Metadaten in der package.json auf Vollständigkeit und Korrektheit. Dazu gehören die version (folgen Sie der semantischen Versionierung), description, author, license und ein Link zur homepage (z.B. das GitHub-Repository).4Veröffentlichung: Nachdem Sie sich bei npm mit npm login angemeldet haben, können Sie Ihr Paket mit dem Befehl npm publish in die Registry hochladen. Stellen Sie sicher, dass die Version bei jedem Update erhöht wird, da npm das Überschreiben einer bestehenden Version nicht erlaubt.177.2. Der n8n-VerifizierungsprozessWährend jede auf npm veröffentlichte Node mit dem korrekten Namen und Keyword von Benutzern manuell in ihrer n8n-Instanz installiert werden kann, bietet der Verifizierungsprozess einen entscheidenden Vorteil: Verifizierte Nodes werden direkt in der n8n-Benutzeroberfläche im "Community Nodes"-Bereich angezeigt und können von allen Benutzern – einschließlich der Nutzer der n8n Cloud – mit einem einzigen Klick installiert werden. Dies erhöht die Sichtbarkeit und das Vertrauen in Ihre Node erheblich.17Die Verifizierung ist jedoch mit strengen zusätzlichen Anforderungen verbunden, die von Anfang an im Entwicklungsprozess berücksichtigt werden müssen.Verschärfte technische Anforderungen:Keine Laufzeit-Abhängigkeiten (dependencies): Dies ist die wichtigste und anspruchsvollste technische Hürde. Um die Sicherheit und Stabilität der mandantenfähigen n8n-Cloud-Umgebung zu gewährleisten, dürfen verifizierte Nodes keine externen Laufzeit-Abhängigkeiten in der dependencies-Sektion der package.json haben. Nur devDependencies sind erlaubt. Das bedeutet, dass jeglicher Code von Drittanbieter-Bibliotheken entweder selbst implementiert oder direkt in das Projekt kopiert ("vendored") werden muss. Diese Anforderung hat erhebliche Auswirkungen auf die Architektur und den Entwicklungsaufwand und muss von Beginn an eingeplant werden.17Einhaltung der Richtlinien: Die Node muss den offiziellen technischen und UX-Richtlinien von n8n vollständig entsprechen.17Automatisierte Prüfungen: n8n führt eine Reihe von automatisierten Prüfungen durch. Die Node muss alle diese Prüfungen erfolgreich bestehen, bevor sie für eine manuelle Überprüfung in Betracht gezogen wird.17Einreichungsprozess: Wenn alle Anforderungen erfüllt sind und die Node auf npm veröffentlicht ist, kann sie über ein offizielles Formular, das in der n8n-Dokumentation verlinkt ist, zur Überprüfung durch das n8n-Team eingereicht werden.17Die Entscheidung, eine Verifizierung anzustreben, ist somit eine strategische. Sie stellt einen Kompromiss dar zwischen dem potenziell höheren Entwicklungsaufwand (aufgrund der "No-Dependencies"-Regel) und der maximalen Reichweite und Glaubwürdigkeit, die eine verifizierte Node genießt.Abschnitt 8: Fortgeschrittene Themen und Best PracticesDie Erstellung einer funktionalen Node ist ein wichtiger Meilenstein. Um jedoch eine wirklich exzellente Node zu entwickeln, die von der Community gerne genutzt wird, bedarf es mehr als nur funktionierendem Code. Dieser Abschnitt beleuchtet fortgeschrittene Konzepte und Best Practices, die sich auf die User Experience und die Integration in moderne n8n-Features konzentrieren.8.1. Best Practices für das Node-Design (User Experience)Eine gut gestaltete Node ist im Grunde ein durchdachtes Produkt. Sie fungiert als Schnittstelle zwischen dem Benutzer und einem potenziell komplexen externen Dienst. Der Erfolg einer Community-Node hängt daher maßgeblich von ihrer Benutzerfreundlichkeit ab. Entwickler sollten sich in die Lage ihrer Benutzer versetzen und sich fragen: Was ist die häufigste Aufgabe, und wie kann ich sie so einfach wie möglich machen?Sinnvolle API-Abstraktion: Es gilt, die richtige Balance zwischen Einfachheit und Flexibilität zu finden. Komplexe, mehrstufige API-Prozesse (z.B. "erstelle einen Kunden, dann erstelle eine Rechnung für diesen Kunden") können in einer einzigen, benutzerfreundlichen Node-Operation zusammengefasst werden. Dies vereinfacht den Workflow für 98% der Anwendungsfälle.25 Gleichzeitig kann es für Power-User sinnvoll sein, auch granulare Operationen anzubieten, die 1:1 einem einzelnen API-Endpunkt entsprechen, um maximale Kontrolle zu ermöglichen.27Intelligente Handhabung der Paginierung: Für API-Endpunkte, die paginierte Ergebnisse zurückgeben, ist es eine bewährte Praxis, eine einfache "Return All"-Option (ein boolescher Schalter) in der UI anzubieten. Wenn diese Option aktiviert ist, kümmert sich die Node im Hintergrund darum, alle Seiten abzurufen und die Ergebnisse zu einem einzigen Array zusammenzufügen. Standardmäßig sollte diese Option jedoch deaktiviert sein, um unnötige API-Aufrufe zu vermeiden und dem Benutzer die Kontrolle zu überlassen.26Vereinfachung vs. Flexibilität: Manche APIs liefern sehr komplexe und verschachtelte Antworten. Eine optionale "Simplify"-Funktion, die standardmäßig aktiviert ist, kann diese Antwort in ein flaches, leicht zu verarbeitendes Schlüssel-Wert-Format umwandeln (ein gutes Beispiel ist die offizielle Typeform-Node). Gleichzeitig sollten Power-User nicht bevormundet werden. Wenn ein Dienst eine mächtige native Abfragesprache unterstützt (wie JQL für Jira oder "Filter by Formula" für Airtable), ist es oft die beste Lösung, ein einfaches Textfeld bereitzustellen, in das Experten ihre Abfragen direkt eingeben können, anstatt zu versuchen, die gesamte Sprache in der UI nachzubilden.268.2. Spezialfall: Nodes als "Tools" für KI-Agentenn8n entwickelt sich rasant im Bereich der künstlichen Intelligenz, insbesondere mit der Einführung von KI-Agenten. Diese Agenten können auf ein Set von "Tools" zugreifen, um Aufgaben auszuführen – und n8n-Nodes können diese Tools sein.23 Dies eröffnet völlig neue Möglichkeiten für die Automatisierung.Implementierung: Um eine Node als Werkzeug für einen KI-Agenten nutzbar zu machen, muss die Eigenschaft usableAsTool: true in der Node-Definition in der .node.ts-Datei gesetzt werden. Dies signalisiert dem n8n-Core, dass die Node von einem Agenten aufgerufen werden kann.Aktivierung: Da dies ein fortgeschrittenes und potenziell sicherheitsrelevantes Feature ist, ist die Nutzung für Community-Nodes standardmäßig deaktiviert. Um es zu ermöglichen, muss der Administrator der n8n-Instanz die Umgebungsvariable N8N_COMMUNITY_PACKAGES_ALLOW_TOOL_USAGE=true setzen. Dies ist eine bewusste Sicherheitsmaßnahme, die sicherstellt, dass nur vertrauenswürdige Community-Nodes als Werkzeuge verwendet werden können.23Die Entwicklung von Nodes, die als KI-Tools konzipiert sind, ist ein zukunftsweisendes Feld, das die Relevanz und den Nutzen von Community-Beiträgen weiter steigern wird.Zusammenfassung und AusblickDie Erstellung einer eigenen n8n Community Node ist ein anspruchsvoller, aber äußerst lohnender Prozess, der die Funktionalität der n8n-Plattform maßgeblich erweitert. Dieser Leitfaden hat den gesamten Lebenszyklus der Node-Entwicklung detailliert nachgezeichnet – von den grundlegenden Voraussetzungen und der Einrichtung der Umgebung über die architektonische Entscheidung zwischen dem deklarativen und programmatischen Stil bis hin zur detaillierten Implementierung, dem rigorosen Testen und der abschließenden Veröffentlichung.Die wichtigsten Erkenntnisse lassen sich wie folgt zusammenfassen:Vorbereitung ist entscheidend: Solide Kenntnisse in TypeScript, npm/pnpm und den n8n-internen Datenstrukturen sind die unabdingbare Basis.Das Starter-Projekt ist der Goldstandard: Die Verwendung des n8n-nodes-starter-Repositorys und des pnpm-Paketmanagers verhindert viele häufige Fehler.Die package.json ist eine funktionale Direktive: Das n8n-Attribut ist kein reines Metadatum, sondern eine kritische Anweisung an den n8n-Core.Die Wahl des Stils ist strategisch: Der deklarative Stil ist für REST-APIs effizient, während der programmatische Stil für komplexe Logik und Trigger unerlässlich ist. Ein hybrider Ansatz ist oft optimal.Testen ist ein iterativer Prozess: Ein effizienter lokaler Test-Workflow mit pnpm run watch und n8n start beschleunigt die Entwicklung erheblich.Verifizierung erfordert Disziplin: Die "No-Dependencies"-Regel für verifizierte Nodes ist eine fundamentale Design-Einschränkung, die von Anfang an bedacht werden muss.Gutes Node-Design ist Produktdesign: Die besten Nodes zeichnen sich durch eine herausragende User Experience aus, die Einfachheit für Anfänger und Flexibilität für Experten bietet.Die n8n-Plattform lebt von ihrer aktiven und engagierten Community. Jeder Entwickler, der eine hochwertige Node erstellt und teilt, trägt maßgeblich zum Wachstum und zur Vielseitigkeit des gesamten Ökosystems bei. Angesichts der rasanten Entwicklungen im Bereich der KI-Integrationen 29 wird die Fähigkeit, spezialisierte Nodes als Werkzeuge für intelligente Agenten zu entwickeln, in Zukunft noch an Bedeutung gewinnen. Die Teilnahme an diesem Ökosystem durch die Entwicklung eigener Nodes ist somit nicht nur eine Möglichkeit, eigene Probleme zu lösen, sondern auch eine Investition in die Zukunft der intelligenten Automatisierung. ---Die Verwaltung von Anmeldeinformationen in n8n ist bewusst von der eigentlichen Node-Logik getrennt. Dies geschieht in einer dedizierten TypeScript-Datei, typischerweise unter /credentials/<name>.credentials.ts. Diese Trennung sorgt für Sicherheit, Wiederverwendbarkeit und Klarheit im Code. Alle hier definierten sensiblen Daten werden von n8n automatisch verschlüsselt in der Datenbank gespeichert.   

1. Die Grundstruktur der Credential-Datei
Jede Credential-Datei definiert eine Klasse, die das ICredentialType-Interface implementiert. Diese Klasse hat mehrere Schlüsseleigenschaften, die ihr Verhalten und Aussehen steuern :   

name: Ein eindeutiger interner Name (z.B. myServiceApi). Dieser Name wird in der .node.ts-Datei verwendet, um die Anmeldeinformationen mit der Node zu verknüpfen. Eine exakte Übereinstimmung ist hier entscheidend, um Fehler zu vermeiden.   

displayName: Der Name, der dem Benutzer in der n8n-Benutzeroberfläche angezeigt wird, z.B. "My Service API".   

documentationUrl: Ein optionaler Link zu einer Dokumentationsseite, die erklärt, wie Benutzer die erforderlichen Anmeldeinformationen erhalten können.   

2. Definition der Benutzeroberfläche: Das properties-Array
Das properties-Array ist das Herzstück der UI-Definition. Es legt fest, welche Felder der Benutzer im Dialogfeld für die Anmeldeinformationen sieht. Jedes Objekt in diesem Array ist eine INodeProperties-Definition, genau wie in der Node selbst.

Beispiel für eine einfache API-Schlüssel-Authentifizierung:

TypeScript

properties: INodeProperties =;
Hier definieren wir zwei Felder: ein Passwort-Feld für den API-Schlüssel und ein normales Textfeld für die Host-URL des Dienstes. Alle verfügbaren UI-Elemente von n8n können hier verwendet werden.   

3. Definition der Authentifizierungslogik: Das authenticate-Objekt
Dies ist der entscheidende Teil, der n8n anweist, wie die vom Benutzer eingegebenen Werte zur Authentifizierung von API-Anfragen verwendet werden sollen. Für die meisten REST-APIs wird der type auf 'generic' gesetzt. Die eigentliche Logik liegt im    

properties-Objekt innerhalb von authenticate.

Hier sind die gängigsten Methoden:

Header-Authentifizierung (z.B. Bearer Token): Die Anmeldeinformationen werden im HTTP-Header gesendet.

TypeScript

authenticate: IAuthenticateGeneric = {
    type: 'generic',
    properties: {
        header: {
            'Authorization': '=Bearer {{$credentials.apiKey}}'
        },
    },
};
In diesem Beispiel wird der Wert aus dem Feld apiKey (definiert im properties-Array) genommen und in den Authorization-Header mit dem Präfix "Bearer " eingefügt.   

Query-String-Authentifizierung: Die Anmeldeinformationen werden als Parameter an die URL angehängt.

TypeScript

authenticate: IAuthenticateGeneric = {
    type: 'generic',
    properties: {
        qs: {
            'api_token': '={{$credentials.apiKey}}'
        },
    },
};
Hier wird ?api_token=WERT_DES_API_SCHLÜSSELS an jede Anfrage angehängt.   

Body-Authentifizierung: Die Anmeldeinformationen werden im Request-Body gesendet, typisch für Formular-Logins.

TypeScript

authenticate: IAuthenticateGeneric = {
    type: 'generic',
    properties: {
        body: {
            'user': '={{$credentials.username}}',
            'pass': '={{$credentials.password}}'
        },
    },
};
Basic Auth: Für die Standard-HTTP-Basisauthentifizierung.

TypeScript

authenticate: IAuthenticateGeneric = {
    type: 'generic',
    properties: {
        auth: {
            'username': '={{$credentials.username}}',
            'password': '={{$credentials.password}}'
        },
    },
};
Die Syntax ={{$credentials.apiKey}} ist entscheidend. Sie weist n8n an, den Wert des Feldes apiKey aus den gespeicherten Anmeldeinformationen zu holen und an dieser Stelle einzufügen.   

4. Fortgeschrittene Anpassung: OAuth2
Für komplexe Authentifizierungsflüsse wie OAuth2 bietet n8n eine elegante Abstraktion. Anstatt den gesamten Handshake (Token-Anforderung, Refresh-Token-Logik) manuell zu implementieren, können Sie die eingebaute oAuth2Api-Klasse von n8n erweitern.

TypeScript

export class MyServiceOAuth2Api implements ICredentialType {
    name = 'myServiceOAuth2Api';
    extends = ['oAuth2Api']; // Dies ist der entscheidende Punkt
    displayName = 'My Service OAuth2 API';
    documentationUrl = 'https://docs.myservice.com/oauth';
    properties: INodeProperties =;
}
Indem Sie extends = ['oAuth2Api'] angeben, erbt Ihre Credential-Klasse die gesamte komplexe Logik für den OAuth2-Fluss. Sie müssen nur noch die dienstspezifischen URLs und Standardwerte überschreiben. n8n kümmert sich dann automatisch um die Weiterleitung des Benutzers, den Austausch des Codes gegen ein Token und das automatische Aktualisieren des Tokens bei Ablauf.   

Einige APIs erfordern jedoch zusätzliche, nicht standardmäßige Parameter im Token-Request-Body (z.B. ein resource-Feld). Dies wird durch die extends-Methode nicht immer direkt unterstützt. In solchen Fällen muss man möglicherweise auf eine generische Credential-Definition zurückgreifen und den Token-Austausch manuell in der Node-Logik durchführen.   

5. Validierung der Anmeldeinformationen: Das test-Objekt
Um dem Benutzer sofortiges Feedback zu geben, ob seine eingegebenen Daten korrekt sind, können Sie ein test-Objekt definieren. n8n führt diese Anfrage aus, wenn der Benutzer auf "Speichern" klickt.   

TypeScript

test: ICredentialTestRequest = {
    request: {
        baseURL: '={{$credentials.hostUrl}}',
        url: '/user/me', // Ein Endpunkt, der eine erfolgreiche Authentifizierung anzeigt
    },
};
Dieser Code weist n8n an, eine GET-Anfrage an https://api.myservice.com/v1/user/me (unter Verwendung des hostUrl-Wertes aus den Anmeldeinformationen) zu senden. Die im authenticate-Objekt definierte Authentifizierungsmethode wird automatisch angewendet. Ein erfolgreicher Statuscode (2xx) führt zu einer Erfolgsmeldung im UI, andernfalls wird ein Fehler angezeigt.   

Für Dienste, die keine einfache HTTP-Überprüfung zulassen (z.B. Datenbankverbindungen), kann stattdessen eine benutzerdefinierte Testfunktion in der Node selbst definiert und über die Eigenschaft testedBy referenziert werden. Dies ist jedoch komplexer und für die meisten API-basierten Nodes nicht notwendig.   


Quellen und ähnliche Inhalte
